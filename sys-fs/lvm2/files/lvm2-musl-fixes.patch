Portability fixes:

- Use fcntl.h for O_RDONLY and friends.
- Only use mallinfo with glibc.
- Use PTHREAD_MUTEX_RECURSIVE rather than the _NP (non portable) variants.

diff -Naurw LVM2.2.02.116.orig/daemons/lvmetad/lvmetad-core.c LVM2.2.02.116/daemons/lvmetad/lvmetad-core.c
--- LVM2.2.02.116.orig/daemons/lvmetad/lvmetad-core.c	2015-01-30 08:19:53.000000000 -0800
+++ LVM2.2.02.116/daemons/lvmetad/lvmetad-core.c	2015-10-13 13:57:02.480116107 -0700
@@ -124,7 +124,7 @@
 	if (!(vg = dm_hash_lookup(s->lock.vg, id))) {
 		if (!(vg = malloc(sizeof(pthread_mutex_t))) ||
 		    pthread_mutexattr_init(&rec) ||
-		    pthread_mutexattr_settype(&rec, PTHREAD_MUTEX_RECURSIVE_NP) ||
+		    pthread_mutexattr_settype(&rec, PTHREAD_MUTEX_RECURSIVE) ||
 		    pthread_mutex_init(vg, &rec))
 			goto bad;
 		if (!dm_hash_insert(s->lock.vg, id, vg)) {
@@ -1152,7 +1152,7 @@
 	ls->log = s->log;
 
 	pthread_mutexattr_init(&rec);
-	pthread_mutexattr_settype(&rec, PTHREAD_MUTEX_RECURSIVE_NP);
+	pthread_mutexattr_settype(&rec, PTHREAD_MUTEX_RECURSIVE);
 	pthread_mutex_init(&ls->lock.pvid_to_pvmeta, &rec);
 	pthread_mutex_init(&ls->lock.vgid_to_metadata, &rec);
 	pthread_mutex_init(&ls->lock.pvid_to_vgid, NULL);
diff -Naurw LVM2.2.02.116.orig/lib/mm/memlock.c LVM2.2.02.116/lib/mm/memlock.c
--- LVM2.2.02.116.orig/lib/mm/memlock.c	2015-01-30 08:19:53.000000000 -0800
+++ LVM2.2.02.116/lib/mm/memlock.c	2015-10-13 13:55:40.820113673 -0700
@@ -136,8 +136,10 @@
 #ifndef VALGRIND_POOL
 	void *stack_mem;
 	struct rlimit limit;
+#ifdef __GLIBC__
 	int i, area = 0, missing = _size_malloc_tmp, max_areas = 32, hblks;
 	char *areas[max_areas];
+#endif
 
 	/* Check if we could preallocate requested stack */
 	if ((getrlimit (RLIMIT_STACK, &limit) == 0) &&
@@ -156,6 +158,7 @@
          *  MMAP'd memory directly. Since MMAP-as-MORECORE does not munmap the
          *  memory on free(), this is good enough for our purposes.
          */
+#ifdef __GLIBC__
 	while (missing > 0) {
 		struct mallinfo inf = mallinfo();
 		hblks = inf.hblks;
@@ -183,14 +186,15 @@
 			break;
 		}
 	}
-
+#endif
 	if ((_malloc_mem = malloc(_size_malloc)))
 		_touch_memory(_malloc_mem, _size_malloc);
-
+#ifdef __GLIBC__
 	/* free up the reserves so subsequent malloc's can use that memory */
 	for (i = 0; i < area; ++i)
 		free(areas[i]);
 #endif
+#endif
 }
 
 static void _release_memory(void)
diff -Naurw LVM2.2.02.116.orig/libdaemon/server/daemon-server.c LVM2.2.02.116/libdaemon/server/daemon-server.c
--- LVM2.2.02.116.orig/libdaemon/server/daemon-server.c	2015-01-30 08:19:53.000000000 -0800
+++ LVM2.2.02.116/libdaemon/server/daemon-server.c	2015-10-13 13:57:24.060116750 -0700
@@ -14,6 +14,7 @@
 #include "daemon-server.h"
 #include "daemon-log.h"
 
+#include <fcntl.h>
 #include <dlfcn.h>
 #include <errno.h>
 #include <pthread.h>
